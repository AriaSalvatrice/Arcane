// Generated by CoffeeScript 2.3.1
(function() {
  // Gods, it feels good to be back to a more civilized language after finishing a 1000 lines C++ project

  // Stuff what we need later
  var addScale, additionalNotes, arcana, base, bpm, bpmTable, i, k, l, m, notePattern, p, patternB, patternC, patternD, patternE, ref, ref1, rotationSteps, scale, scaleTable, selectedScale, wish;

  if ((base = Array.prototype).shuffle == null) {
    base.shuffle = function() {
      var i, j, k, ref;
      if (this.length > 1) {
        for (i = k = ref = this.length - 1; (ref <= 1 ? k <= 1 : k >= 1); i = ref <= 1 ? ++k : --k) {
          j = Math.floor(Math.random() * (i + 1));
          [this[i], this[j]] = [this[j], this[i]];
        }
      }
      return this;
    };
  }

  p = function(text) {
    return process.stdout.write(text + "\n");
  };

  // Those numbers can be generated directly
  arcana = Math.floor(Math.random() * 22);

  patternB = Math.floor(Math.random() * 65536);

  patternC = Math.floor(Math.random() * 65536);

  patternD = Math.floor(Math.random() * 65536);

  patternE = Math.floor(Math.random() * 65536);

  wish = Math.floor(Math.random() * 4);

  // BPM: values between 90 and 150 twice as likely.
  bpmTable = (function() {
    var results = [];
    for (var k = 60; k <= 180; k++){ results.push(k); }
    return results;
  }).apply(this).concat((function() {
    var results = [];
    for (var k = 90; k <= 150; k++){ results.push(k); }
    return results;
  }).apply(this));

  bpm = bpmTable[Math.floor(Math.random() * bpmTable.length)];

  // Scales. First we build the table
  scaleTable = [];

  addScale = function(scale, weight) {
    var i, k, ref, results;
    results = [];
    for (i = k = 1, ref = weight; (1 <= ref ? k <= ref : k >= ref); i = 1 <= ref ? ++k : --k) {
      results.push(scaleTable.push(scale));
    }
    return results;
  };

  // Add them all only once starting on C

  //         CCDDEFFGGAAB Weight
  //          # #  # # #    |
  addScale("X X XX X X X", 1); // Test

  addScale("XX XX XX  XX", 1); // Test

  addScale("X XX X      ", 1);

  addScale("X XX X   X  ", 1);

  addScale("X XX X X X  ", 1);

  // Select the scale and rotate it randomly
  selectedScale = scaleTable[Math.floor(Math.random() * scaleTable.length)];

  rotationSteps = Math.floor(Math.random() * 12);

  if (rotationSteps > 0) {
    for (i = k = 1, ref = rotationSteps; (1 <= ref ? k <= ref : k >= ref); i = 1 <= ref ? ++k : --k) {
      selectedScale = selectedScale[selectedScale.length - 1] + selectedScale.substring(0, selectedScale.length - 1);
    }
  }

  // Convert it to binary
  selectedScale = selectedScale.replace(/X/g, "1").replace(/ /g, "0");

  scale = parseInt(selectedScale, 2);

  // Build an array of valid scale notes & pad end with additional notes
  notePattern = [];

  for (i = l = 0; l <= 12; i = ++l) {
    if (selectedScale[i] === "1") {
      notePattern.push(i);
    }
  }

  additionalNotes = notePattern;

  notePattern = notePattern.shuffle();

  additionalNotes = additionalNotes.shuffle();

  if (notePattern.length < 8) {
    for (i = m = 0, ref1 = 7 - notePattern.length; (0 <= ref1 ? m <= ref1 : m >= ref1); i = 0 <= ref1 ? ++m : --m) {
      notePattern.push(additionalNotes[i]);
    }
  }

  // Done. We print it. Pipelines do the rest.
  // No, I'm not gonna whip out a JSON parser to write 20 lines. Frick the h*ck off.
  p("{");

  p(`  "arcana": ${arcana},`);

  p(`  "patternB": ${patternB},`);

  p(`  "patternC": ${patternC},`);

  p(`  "patternD": ${patternD},`);

  p(`  "patternE": ${patternE},`);

  p(`  "scale": ${scale},`);

  p("  \"notePattern\": [");

  p(`    ${notePattern[0]},`);

  p(`    ${notePattern[1]},`);

  p(`    ${notePattern[2]},`);

  p(`    ${notePattern[3]},`);

  p(`    ${notePattern[4]},`);

  p(`    ${notePattern[5]},`);

  p(`    ${notePattern[6]},`);

  p(`    ${notePattern[7]}`);

  p("    ],");

  p(`  "bpm": ${bpm},`);

  p(`  "wish": ${wish}`);

  p("}");

}).call(this);
